#######################################设计模式###################################  
1,迭代模式，将迭代的方法抽离出来  
2，适配器模式，中间类实现一个类继承另一个类  
      委托模式，中间类实现一个类，聚合另一个类        
3，模版模式，抽象父类提供抽象方法供子类实现  
4，工厂模式，一个抽象工厂类作为创建产品的模版模式，一个抽象的产品类，由抽象工厂子类来执行具体的工厂流程生成具体的产品，具体的产品由子类实现  
5，单例模式，声明静态对象变量，私有化构造函数，提供一个返回静态对象变量的方法  
6，原型模式，一个产品接口继承Cloneable接口提供创建自身对象的方法，使用一个管理类来管理产品(map映射)，产品的子类重写createClone方法  
7，建造者模式，通过一个监工类聚合另一个构建抽象类，具体的实现由子类完成  
8，抽象工厂模式，创建抽象工厂，具体的工厂生产具体的零件，具体的零件继承自抽象的零件组件，抽象的组件继承抽象的项目，具体的产品由抽象的工厂的子类产生，产品和零件是聚合关系  
9，桥接模式，将类的功能层次结构与实现层次结构分离，一个产品类聚合另一个抽象类，产品子类增强实现，对父类聚和对象进行初始化，抽象类的子类负责具体的实现  
10，策略模式，整体的替换算法，聚合策略接口，通过委托可以整天的替换算法  
11，Composite混合模式，能够使容器和内容具有一致性，创造出递归结构。将多个对象结合在一起当作一个对象处理  
12，装饰模式，子类和装饰类都继承抽象父类，装饰类聚合父类，被具体的子类实现。重点在于继承相同的父类，其中一个子类包含装饰另一个子类。缺点是会导致程序中增加许多功能相似的类。抽象和接口的使用，取决于耦合程度  
13，访问模式，访问数据结构并处理数据。父类继承一个接口，作为被访问的入口，然后聚合访问者抽象类，被具体的实现处理  
14，责任链模式，将多个对象组成一条责任链。抽象类模版模式设置执行顺序和设置具体的实现类处理，子类具体实现。主要处理的时间问题  
15，Facade外观模式,封装接口方法简化其他功能的调用  
16，中介者模式，调用多个对象之间的关系，需要用到中介者模式  
17，观察者模式，聚合观察者类，提供注册不同观察者到集合的方法，子类发生变化时，通过调用观察者的方法，通知所有观察者的实现  
18，,备忘录模式，一个类保存了另一个类的信息，需要的时候复制出来进行还原  
19，状态模式，利用类来表示状态  
20，Flyweight模式，通过单例模式和map共享实例，实现轻量级的框架  
21，代理模式,实现相同的接口，聚合另一个子类进行访问控制  
22，命令模式，命令当前请求对象  
23，解释器模式  

